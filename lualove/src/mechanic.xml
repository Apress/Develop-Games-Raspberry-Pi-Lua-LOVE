<chapter xml:id="mech">
  <!-- Ch08 -->
    <title>Battle cards</title>

    <para>
      As of the previous chapter, both the menu and game screens are
      accessible when your program launches. In this chapter, you code
      the main game mechanics. The logic is similar to what you have
      already done to create your Blackjack game, so elements of this
      chapter will feel familiar, although there are unique features to
      Battlejack that pose new challenges.
    </para>

    <para>
      The central game mechanic is this&#58; the goal is, like
      Blackjack, to reach 21 first. Unlike Blackjack, an excess of 21
      is not a bust but still wins, and the player can
      &#34;attack&#34; the dealer&#39;s stash of cards.
    </para>

    <para>
      During the game, the player clicks their deck to draw a card. On
      their turn, the player may select cards to cancel out a card in
      the AI&#39;s stash. This is an <emphasis>attack</emphasis>, and
      an attack may be bolstered by a powerup card if the player has
      one available. Alternately, a player may place a card from their
      hand to their own score box in an attempt to reach 21 before the
      AI does. If the player draws a black card, then at the start of
      the dealer&#39;s turn, one black card from the player&#39;s hand
      is added to the dealer&#39;s stash.
    </para>

    <para>
      If a joker is drawn from either deck, then it destroys the stash
      of the opposition.
    </para>

    <para>
      In code, this game requires a lot of data tracking. Your code
      must keep track of what cards remain in each deck, what cards are
      in the player&#39;s hands, which of those cards are currently
      selected as cards to go into battle against the dealer, which
      cards are in the dealer&#39;s hand, which of the dealer&#39;s
      cards have been eliminated, the location of each card on the
      screen, and much more. In Lua terminology, that means
      you need tables &#40;you would use &#34;classes&#34; or
      &#34;fields&#34; in other languages&#41;.
    </para>

    <section xml:id="mech-cardtable">
    <info>
      <title>Card table</title>
    </info>

    <para>
      In your Blackjack game, each card was its own Lua table, with a
      unique <literal>self.suit</literal> and <literal>self.value</literal>
      and <literal>self.img</literal> all its own, which you were able
      to call from your main script when you needed to calculate
      the total score or when you needed to tell LÖVE what image to
      draw on the screen.
    </para>

    <para>
      Create a <filename>card.lua</filename> file in your project
      directory. This file will be the card table&#58; any time a card
      is generated for display on screen, it will inherit all the
      attributes contained in this file. As you might expect, each
      card requires a face image and a numeric value and also a
      color. Each card also needs to keep track of its own location on
      the screen&#58; this is useful in games, because by updating one
      item&#39;s attributes, you can always restore or re-draw the
      game state after major events.
    </para>

<programlisting><![CDATA[
Card = { }

function Card.init(c,v,f,x,y)
   -- generate card
   local self = setmetatable({}, Card)
   self.color = c
   self.value = v
   self.face  = f
   self.x = x
   self.y = y
   self.r = 0 --rotation
   
   return self
end
]]></programlisting>

<para>
  This is a slightly more complex version of your Blackjack card
  table. Of course, none of these values mean anything
  yet. They&#39;re just empty fields that need to be populated by data
  you feed into the table when generating a new card.
</para>

<para>
  There are still a few more fields needed. First of all, each card
  needs an image. This would be identical to your Blackjack game were
  in not for the addition of the Joker to this deck. In fact, you
  could render the Joker and back images basically the same as all the
  other cards by naming their image files as you named the face cards
  &#40;<filename>0-joker.png</filename>,
  <filename>0-back.png</filename>&#41; but then you&#39; need a copy
  of each in the <filename>red</filename> and
  <filename>black</filename> directories, which is redundant
  data. There&#39;s nothing wrong, necessarily, with that approach, but it
  wouldn&#39;t scale were this a much larger game with really big
  assets, while allowing for deviations in the code is cheap, and worth
  while.
</para>

<para>
  Add this block of code above the <literal>return self</literal> line
  of your <filename>card.lua</filename> file&#58;
</para>

<programlisting><![CDATA[
   if self.face == "back" or self.face == "joker" then
      self.img = love.graphics.newImage("img" .. d .. self.face .. ".png")
   else
      self.img = love.graphics.newImage("img" .. d .. self.color .. d .. self.value .. "-" .. self.face .. ".png")
   end
]]></programlisting>

<para>
  And finally, it&#39;s always important to be able to ascertain an
  object&#39;;s size. A game object&#39;s size is vital for collision
  detection&#58; it&#39;s how you tell where to draw the next object
  without drawing on top of the previous one, and it&#39;s how you
  detect whether the player has clicked on one object or another.
</para>

<para>
  Lua has functions specifically for the task of determining image
  size, but your program is going to scale your graphics down &#40;as
  in the Blackjack game&#41; so that the screen size can be
  changed. Technically, you could just use Lua&#39;s size detection
  and multiply the result by your scale, or you can enter the size
  value as part of each card. Both do the same thing, but since the
  size of objects gets used frequently, it&#39;s &#34;cheaper&#34; to
  do the calculation once and enter the value as a variable than to do
  the maths every time a user interacts with the screen.
</para>

<para>
  Add this above the <literal>return self</literal> line of your
  <filename>card.lua</filename> file&#58;
</para>

<programlisting><![CDATA[
   self.wide = self.img:getWidth()*scale
   self.high = self.img:getHeight()*scale
]]></programlisting>

<para>
  The value of the <varname>scale</varname> variable has yet to be
  created, but as long as it does get defined before
  <filename>card.lua</filename> is actually used, there won&#39;t be a problem.
</para>
</section>

  <section xml:id="mech-game">
    <info>
      <title>Game state</title>
    </info>

    <para>
      Currently, entering the game state of your application sets the
      active <varname>STATE</varname> to <literal>game</literal>,
      which in turn causes the main loop to invoke your custom
      <literal>game.draw()</literal> function, which renders a
      colored background. This all happens in the
      <filename>game.lua</filename> file, so open that in Geany so you
      can make some changes.
    </para>

    <para>
      The <filename>game.lua</filename> file is the logical place to
      define important game-related variables, because it&#39;s within
      this file that the mechanics and game data tracking happens.
    </para>

    <para>
      To begin with, the game logic needs access to your card class
      and to the configuration file that defines what cards exist. Add
      the top two lines of this sample code to the top of your
      <filename>game.lua</filename> file:
    </para>
    
<programlisting><![CDATA[
require("card")
local inifile = require('inifile')
game = {}
]]></programlisting>

<para>
  If you have not already done so, use
  <application>luarocks</application> to install the
  <literal>inifile</literal> Lua library into your project
  directory&#58;
</para>
    
<programlisting><![CDATA[
$ cd ~/battlejack
$ luarocks install --tree=local inifile
]]></programlisting>

<para>
  Based on both the <filename>card.lua</filename> file and your
  previous experience with your Blackjack game, you can anticipate a
  few important variables that can be defined whether or not your code
  has a need for them yet.
</para>

<para>
  Start by defining some environment variables&#58; eventually, LÖVE
  needs to know who is running the game so that it can store save
  files. Lua provides the <literal>os.getenv('HOME')</literal>
  function to discover a user&#39;s home directory. On Linux, this is
  a folder in a directory literally called <literal>home</literal>,
  while on Mac this is a folder within the <literal>Users</literal>
  directory, and on Windows it is a location usually on the
  <literal>C</literal> drive. The point is, you don&#39;t have to
  worry about where a user keeps their personal data files, because
  Lua finds that out for you.
</para>

<para>
  Another thing that changes from system to system is the separator
  character used to delimit directories from one another. For
  instance, on the Raspberry Pi, as on any Linux or Mac system, the
  separator character is a forward slash. The location to any
  file or folder on the system can be predictably written out in plain
  text. For example&#58;
  <filename>/home/pi/battlejack/img/joker.png</filename>. On Windows,
  however, the separator character is traditionally a backslash&#58;
  <filename>C:\\My Documents\example\img\joker.png</filename>. Lua can
  detect this for you, too, with its <literal>package.config</literal>
  function.
</para>

<para>
  Add these lines to your <filename>game.lua</filename> file. The
  first line is already in your file and is shown for context&#58;
</para>

<programlisting><![CDATA[
game = {}

home = os.getenv('HOME')
d    = package.config:sub(1,1) -- path separator
]]></programlisting>

<para>
  Next, your game needs several tables to serve as decks of cards in
  various states of play. Create tables called
  <varname>hand</varname> and <varname>horde</varname> to serve as the
  player and AI active hands, tables called <varname>deck</varname>
  and <varname>ai</varname> to serve as shuffled draw decks for player
  and AI, a table called <varname>back</varname> containing the
  backside of the player and AI decks to serve as the clickable item
  when a player wants to draw a new card, and a <varname>grab</varname>
  table to serve as a staging area for cards a player is about to send
  into battle.
</para>

<para>
  Finally, create a <varname>winner</varname> variable to mark whether
  or not a winner has been found. By default, set it to <literal>nil</literal>. Pull card data from
  your configuration file into a variable called
  <varname>set</varname> using the <literal>inifile</literal>
  function.
</para>

<para>
  Here&#39;s the code you need to add. The first two lines are for context&#58;
</para>

<programlisting><![CDATA[
home = os.getenv('HOME')
d    = package.config:sub(1,1)
hand  = {} --player hand
horde = {} --ai hand
deck  = {} --player deck
ai    = {} --ai deck
back  = {} --clickable deck icons
grab  = {} --selected for battle
winner = nil

-- parse the INI file and
-- put values into a table called set
set = inifile.parse('deck.ini')
]]></programlisting>

<para>
  Your game world needs a <varname>scale</varname> variable to use when scaling
  down large card images to something that fits on the game
  screen. Since checking for the appropriate scale is something that will have
  to be done any time a player changes the screen mode between
  windowed and fullscreen, setting the <varname>scale</varname> needs
  to be a function that can be called as necessary. Create a new
  function called <literal>game.scaler()</literal> in
  <filename>game.lua</filename> and use math to determine the optimal
  scale factor given the current size of the screen&#58;
</para>

<programlisting><![CDATA[
function game.scaler(WIDE,card)
   slot = WIDE/6
   scale = slot/card
   pad = WIDE*0.04
   return scale
end
]]></programlisting>

<para>
  The first logical place to call this function is any time a new game
  begins. The function takes the width of the screen, which is a
  global variable established in <filename>main.lua</filename>, and
  the native size of a card graphic. If you&#39;ve made your own
  graphics for this game, then you must determine the size of your
  graphic yourself &#40;you can find it in GIMP, if you&#39;re not
  sure&#41;. The example graphics included with the source code of
  this book are 790 pixels wide.
</para>

<para>
  The <literal>game.scaler()</literal> function assumes that
  approximately six cards should fit horizontally across the screen
  &#40;WIDE/6&#41;. This calculation renders the width of each card in
  pixels, which itself is important enough to keep in a global
  variable called <varname>slot</varname>, which keeps cards from
  overlapping when being drawn. The <varname>slot</varname> value
  divided by the unscaled size of a card provides a decimal number by
  which all cards may be scaled in order to fit 6 across the screen.
</para>

<para>
  Add this line of code to your <literal>game.new()</literal>
  function&#58;
</para>

<programlisting><![CDATA[
scale = game.scaler(WIDE,790)
]]></programlisting>

<para>
  With these functions and variables in place, you can at least draw
  the most rudimentary of cards screen.
</para>

<para>
  Setting the card table is an activity that needs to happen at the
  beginning of each new round, so it deserves its own function. Create
  one now, called <literal>game.setup()</literal>, and use your card
  library to generate cards to represent the player deck and the AI deck.
</para>

<programlisting><![CDATA[
function game.setup()
   -- create GUI deck for player
   card = Card.init("c","v","back",pad,HIGH-slot-(pad*2))
   back[#back+1] = card
   -- create GUI deck for ai
   card = Card.init("c","v","back",WIDE-(slot/2)-pad,slot-(pad))
   back[#back+1] = card

   -- draw table background
   ground = love.graphics.newQuad(0,0,WIDE,HIGH,150,150)
   tile   = love.graphics.newImage('img' .. d .. 'tile.jpg')
   tile:setWrap('repeat','repeat')
end
]]></programlisting>

<para>
  The first card you generate is the &#34;top&#34; of the draw deck
  for the player. Since it&#39;s the back of a card, it has no color
  or value, so you pass in the dummy values &#34;c&#34; and
  &#34;v&#34;, which the card library ignores once it sees that the
  card being generated is of the <literal>back</literal> type. The
  card&#39;s X position is set at the left plus the value of
  <varname>pad</varname>, a variable set in
  <filename>main.lua</filename> to provide padding around the edges of
  the screen. The card&#39;s Y position is calculated from the height
  of the screen.
</para>

<para>
  The card generated is added to the <literal>back</literal>
  table. Then the same variable is used to generate a second card to
  represent the AI&#39;s draw deck, using new X and Y values so that
  the card&#39;s placement is in the top right &#40;across the virtual
  table&#41; instead of the bottom left. This second card is also
  added to the <literal>back</literal> table.
</para>

<para>
  Finally, a proper tabletop is defined. Currently, the game mode just
  renders a flat color in the background, but Battlejack deserves
  something more exciting. Rendering an array based on a texture or
  pattern is pretty common for a game engine, and LÖVE provides the
  <literal>love.graphics.newQuad</literal> function to map tiles
  across a given space. Specifically, this code defines a quad of the width
  and height of the screen, with tiles sized 150 by 150 pixels
  &#40;which happens to be the size of the tile pattern included with
  the source code of this book&#40;. The tile is defined using the
  <varname>d</varname> variable to ensure compatibility with whatever
  system the game is running on, and the tile mode is set to wrap seamlessly
  across all available space.
</para>

<para>
  Currently, nothing calls the <literal>game.setup()</literal>
  function, so trigger it at the end of the
  <literal>game.new()</literal> function, since a user starting a new
  game certainly expects their game to be set up&#58;  
</para>

<programlisting><![CDATA[
   game.setup()
]]></programlisting>

<para>
  Of course, nothing actually gets drawn unless it appears in the
  <literal>love.draw()</literal> function, which in this program is
  aliased to the <literal>draw()</literal> function of whatever
  <varname>STATE</varname> the user is in. For game play, the user is
  in the <literal>game</literal> state, so you must add your draw
  commands to <literal>game.draw()</literal>.
</para>

<para>
  Clear out the code currently in the <literal>game.draw()</literal>
  function, replacing it with this&#58;
</para>

<programlisting><![CDATA[
function game.draw()
   love.graphics.setColor(1,1,1)

   -- set background
   love.graphics.draw(tile,ground,0,0)

   --hand player
   card = back[1]
   love.graphics.draw(card.img,card.x,card.y,0,scale,scale,0,0)
   --horde ai
   card = back[2]
   love.graphics.draw(card.img,card.x,card.y,0,-1*scale,-1*scale,card.img:getWidth()/2, card.img:getHeight()/2)
end
]]></programlisting>

<para>
  After setting the color to white to ensure that everything is drawn
  at 100% opacity, the tiles are drawn to create the tabletop. Order
  is important, here, so the tabletop must be drawn
  <emphasis>before</emphasis> cards or drawn or else the cards will be
  drawn &#34;under&#34; the table.
</para>

<para>
  To draw the two card decks, you populate a temporary
  <varname>card</varname> variable with one object from the
  <literal>back</literal> table and use that data to draw the
  graphic. Since the <literal>back</literal> table contains relatively
  little data, manually pulling out an entry is simple &#40;the contents of other
  tables you have created will be far more dynamic and will require
  for-loops&#41;
</para>

<para>
  Launch your game to verify that all your code is correct so
  far. Correct any errors and make adjustments as needed, and then
  it&#39;s time to set up the deck creation functions.
</para>

</section>

<section xml:id="mech-build">
  <info>
    <title>Deck building</title>
  </info>

  <para>
    A key element of Battlejack, like any card game, is the random
    nature of the game elements. Functionally, that means your
    program needs a reliable set of methods you can use repeatedly to
    create freshly randomized decks of cards based on the card
    definitions you have set forth in your card definition INI
    file.
  </para>
  
  <para>
    To create decks for Battlejack, you must fill two distinct tables
    with card definitions, with one being filled with red cards and
    the other with black. However, it&#39;s part of the game design
    that there are six black &#34;mole&#34; cards inserted into the
    player deck, so six cards must be stolen from one deck and
    inserted into the other. Additionally, a Joker must be placed in
    each deck but not accidentally stolen when the black
    &#34;mole&#34; cards are inserted into the player deck. And
    finally, the decks each much be shuffled to ensure
    unpredictability.
  </para>

  <para>
    In your <filename>game.lua</filename> file, create four new
    functions&#58; <literal>game.setsplit()</literal>,
    <literal>game.mole()</literal>, <literal>game.joker()</literal>,
    and <literal>game.shuffle()</literal>.
  </para>

  <para>
    First, to create two distinct tables containing card definitions
    for each color, you need to know which part of the INI file to
    use. For lack of better terminology, call this a
    <emphasis>stack</emphasis> &#40;as in a stack of cards&#41;. You
    also need to know which deck you are building&#58; red or
    black. Essentially, this is determining whether the deck is meant
    for a human player or for the computer, so call this attribute
    <emphasis>human</emphasis>. Finally, you need a table to build the
    deck into, and you need to know how many stacks to put into each
    deck, because it would be a very quick game were there only one
    copy of each card.
  </para>
  
<programlisting><![CDATA[
function game.setsplit(stack,human,tbl,n)
   for count = 1, n do
      for i,card in pairs(set[stack]) do
	 if human == 1 then
	    color="red"
	 else
	    color="black"
	 end
	 tbl[#tbl+1]=color .. "," .. card
      end
   end
   return tbl
end
]]></programlisting>

<para>
  This code uses a for-loop to repeat the same action for as
  many times &#40;n&#41; as you proscribe when calling the
  function. The action that it takes is another for-loop that iterates
  over the <varname>set</varname> variable, containing the contents of
  the <literal>card</literal> section of your INI file, and assigns a
  color to the card definition, and then places the card definition
  into whatever table you have told it to build into.
</para>

<para>
  The table is returned at the end of the function, so you call the
  function as a constructor method, with its results placed into a
  destination of your choosing. For now, call the function in the
  <literal>game.setup()</literal> function&#58;
</para>

<programlisting><![CDATA[
-- create sets
deck = game.setsplit("card",1,deck,2)
ai   = game.setsplit("card",0,ai,2)
]]></programlisting>
  
<para>
  Next, you need to steal 6 cards from the black deck. If you do that
  immediately after building the decks, however, the same black cards
  will be stolen every time because no randomness has yet been
  introduced into the decks. For this reason, you need to develop the
  shuffle method first. 
</para>

<para>
  As you might expect, asking a computer to do something randomly
  requires the use of Lua&#39;s <literal>math.random()</literal>
  function. This needs a random <emphasis>seed</emphasis>, and the
  easiest ever-changing source of numbers in a computer is its
  clock. Activate a random seed at the top of your
  <filename>game.new()</filename> function&#58;
</para>

<programlisting><![CDATA[
math.randomseed(os.time())
]]></programlisting>

<para>
  To cause a table to &#34;shuffle&#34; its order, you take the table
  into a function, determine how many items it has in it, and then
  take a random number between 1 and the number of items in the
  table. Take the current item and swap it with the random numbered
  item. Repeat this until each item has traded places with some other
  item.
</para>

<programlisting><![CDATA[
function game.shuffle(tbl)
   local len = #tbl
   for i = len, 1, -1 do
      local j = math.random( 1, i );
      tbl[i], tbl[j] = tbl[j], tbl[i];
   end
   return tbl;
end
]]></programlisting>

<para>
  Now that you have a way to shuffle decks, it&#39;s safe to steal
  cards from one to sabotage the other. For the
  <literal>game.mole()</literal> function, you first shuffle the AI
  deck to ensure you&#39;re grabbing random cards. Then you just take
  the first number of cards &#40;the rules say 6, but in case the
  function gets used for some other purpose later, use
  <literal>n</literal> to signify a configurable number&#41; and
  insert those cards into your target deck. Once inserted into the new
  deck, remove the stolen entry from the source table.
</para>

<programlisting><![CDATA[
function game.mole(src,tgt,n)
   -- shuffle 
   src = game.shuffle(src)
   
   for count = 1, n do
      tgt[#tgt+1] = src[count]
      table.remove(src,count)
   end
end
]]></programlisting>

<para>
  The last function inserts a Joker card into a deck. It&#39;s
  a straight-forward table append&#58;
</para>

<programlisting><![CDATA[
function game.joker(tbl,human)
   if human == 1 then
      color="red"
   else
      color="black"
   end
   tbl[#tbl+1] = color .. ",joker,0"
   return tbl;
end
]]></programlisting>

<para>
  Now that the functions to build decks exist, you must use
  them. It&#39;s reasonable to first call these functions in the
  <literal>game.setup()</literal> function, since that will presumably
  be called any time a new game is started. Add this code to your
  setup&#58;
</para>

<programlisting><![CDATA[
-- create sets
deck = game.setsplit("card",1,deck,2)
ai = game.setsplit("card",0,ai,2)
-- steal cards from black
game.mole(ai,deck,6)   
-- insert joker
deck = game.joker(deck,1)
ai   = game.joker(ai,0)
-- shuffle
deck = game.shuffle(deck)
ai = game.shuffle(ai)
]]></programlisting>
  
<para>
  If you launch your game now, it runs successfully but very
  quietly. For temporary insight into the inner workings of the game,
  add this block of code to the end of the <literal>setup()</literal>
  function&#58;
</para>

<programlisting><![CDATA[
   print("deck -----------------")
   for i,card in pairs(deck) do
      print(card)
   end
   print("ai -----------------")
   for i,card in pairs(ai) do
      print(card)
   end
]]></programlisting>

<para>
  Launch the game and look at the terminal to see a text list of the
  cards in each deck.
</para>

<para>
  The next step, though, is to transform all of this setup work into a
  playable game.
</para>

</section>

<section xml:id="mech-play">
  <info>
    <title>Playable cards</title>
  </info>

  <para>
    Playing Battlejack is a three step process&#58; the user must draw
    a card, the user must select cards to use in an attack, and then the user must choose
    a target for an attack. That means your code needs functions to
    visually produce a card into the player&#39;s hand, to mark cards
    as selected, and finally to resolve a battle.
  </para>

  <para>
    Create a new function called <literal>game.cardgen()</literal>
    that accepts a deck as an argument. This function&#39;s job will
    be to parse the next available card definition from a deck, to use
    your card library to create a card object with all the necessary
    attributes &#40;image, width, height, position, and so on&#41;,
    and to add it to the table representing the player hand or the AI horde.
  </para>

  <para>
    As cards are drawn from a deck, of course, they must be removed
    from that deck, or else the same card would be drawn for
    eternity. For that reason, the deck table becomes populated with
    <literal>nil</literal> entries as the game progresses, so your
    function must be programmed to skip over empty entries.
  </para>

  <para>
    When a valid entry is found, the text must be parsed. Card data, as
    you were able to see when you wrote the temporary introspection
    for your last functions, is separated by commas; for example,
    <literal>black,goblin,5</literal> or
    <literal>red,arcanist,3</literal>. To extract information from
    this, you use the Lua <literal>match</literal> function, which
    permits you to provide a <emphasis>regular expression</emphasis>
    representing the pattern of text you expect to see in each card entry
    of a deck. Specifically, you tell LÖVE to expect any text followed
    by a comma, and then any text followed by another comma, and
    finally any text. Each component found by match is placed into a
    unique variable, which gets passed to your card library.
  </para>  

<programlisting><![CDATA[
function game.cardgen(src)
   local count = 0
   while src[count] == nil do count = count+1 end
   local c,f,v = src[count]:match("([^,]+),([^,]+),([^,]+)")
   card = Card.init(c,v,f,nil,nil)
   src[count] = nil

   if src == deck then
      hand[#hand+1] = card
      card.y = HIGH-(pad*2)-slot
   else
      horde[#horde+1] = card
      card.y = pad/4
   end 
   return card
end
]]></programlisting>
  
<para>
  Now you need something to trigger your new function. Clicking on the
  back of the player&#39;s deck should produce one card for the
  player, and one card for the AI. Unlike in your Blackjack game,
  there are several clickable objects in this game, so your
  <literal>mousereleased</literal> function needs to be able to
  detect exactly what clicked. This is best done with a dedicated
  click detection function that analyzes the X and Y coordinates of a
  click, compares it with the dimensions of some given object, and
  determines whether or not the X and Y of the click falls within the
  boundaries of the object.
</para>

<programlisting><![CDATA[
function game.clicker(x,y,tgt)
   return (
        x < tgt.x + tgt.wide and
        x > tgt.x and
        y < tgt.y + tgt.high and
        y > tgt.y
    )
    -- returns True or False
end
]]></programlisting>

<para>
  Notice that this function is a little different than any of the
  functions you&#39;ve written so far&#58; it returns either true or
  false depending on the results of its calculation. This is a
  convenience that lets you use the result of a call to the function
  as a sort of switch&#59; if it returns false, then you know that
  there&#39;s no reason to continue analyzing a click.  
</para>

<para>
  Now when the player releases mouse button 1, look at both cards in
  the <literal>back</literal> table. Check whether either deck was
  clicked, but restrict the check to the lower half of the screen
  &#40;rendering clicks on the AI deck meaningless&#41;. If so,
  generate one card for the player and one card for the AI.
</para>

<programlisting><![CDATA[
function game.mousereleased(x,y,btn)
   if btn == 1 then
      --take a card
      for i,obj in pairs(back) do
	 if game.clicker(x,y,obj) and y > HIGH-slot-pad then
	    card = game.cardgen(deck)
	    card = game.cardgen(ai)
	 end --if
      end --for
   end --if
end
]]></programlisting>

<para>
  As usual, nothing actually gets drawn to screen unless it&#39;s in
  accounted for in the <literal>draw()</literal> function, so add two
  new for-loops, one for each hand, to your draw loop. The first two
  lines are for context&#58;
</para>

<programlisting><![CDATA[
 -- set background
love.graphics.draw(tile,ground,0,0)

-- draw cards 
for i,obj in pairs(horde) do --ai
   obj.x = WIDE-(slot*i)-slot-pad
   love.graphics.draw(obj.img,obj.x,obj.y,0,scale,scale,0,0) 
end

for i,obj in pairs(hand) do --player
   obj.x = pad+(slot*i)
   love.graphics.draw(obj.img,obj.x,obj.y,obj.r,scale,scale,0,0)
end
]]></programlisting>

<para>
  Launch the game and draw some cards.
</para>

</section>

<section xml:id="mech-battle">
  <info>
    <title>Battle</title>
  </info>

  <para>
    Sending cards into battle is also all about click detection. Since
    the user can select more than one card to combat an enemy card,
    you must mark selected cards as selected until an enemy target is
    clicked. You already have a table called <literal>grab</literal>,
    and so it will serve as a kind of extension of the player&#39;s
    hand, containing any cards that have been clicked in preparation
    for battle. Of course, clicking an already grabbed card causes it
    to be de-selected.
  </para>

  <para>
    To detect whether a card is selected or not, you need a function
    to check for the presence of a specific card &#40;the one that a
    player has clicked on&#41; in a table &#40;the
    <literal>grab</literal> table&#41;. Create a function called
    <literal>game.isselected()</literal> and use it to cycle through a
    table in search of a specific card&#58;
  </para>

<programlisting><![CDATA[
function game.isselected(src,tgt)
   for k,v in pairs(tgt) do
      if v==src then
	 return k
      end
   end
end
]]></programlisting>
    
<para>
  Now that you have the ability to detect whether a card has been
  grabbed yet, you can process mouse clicks. For the action of
  grabbing a card and adding it to the <literal>grab</literal> table,
  you can use a the LÖVE <literal>mousepressed</literal> function,
  simply to avoid overloading the <literal>mousereleased</literal>
  function with too many checks. 
</para>

<para>
  The logic is simple. If mouse button 1 is pressed, check to see
  whether the object clicked is in the player&#39;s <literal>hand</literal> table. If it
  is, but it is not in the <literal>grab</literal> table, then change
  its position slightly to show that it is selected, and add it to the
  <literal>grab</literal> table. If it&#39;s already in the
  <literal>grab</literal> table, then move it back in line with the
  other cards and remove it from the table.
</para>
  
<programlisting><![CDATA[
function love.mousepressed(x,y,btn)
   if btn == 1 then
      for i,obj in pairs(hand) do
	 if game.clicker(x,y,obj) and not game.isselected(obj,grab) then
	    obj.y = obj.y - (slot*2*scale)
	    grab[#grab+1] = obj
	 elseif game.clicker(x,y,obj) and game.isselected(obj,grab) > 0 then
	    obj.y = HIGH-(pad*2)-slot
	    k = game.isselected(obj,grab)
	    grab[k] = nil
	 end
      end
   end
end
]]></programlisting>

<para>
  Launch the game and try selecting some cards from your hand.
</para>

<bridgehead>Visual effects</bridgehead>

<para>
  Selecting cards for battle should be an exciting prospect in the
  game. After all, it&#39;s the central mechanic; without this, the
  game is basically Blackjack. While elevating the card on the table
  is pragmatically effective, it&#39;s not very flashy. 
</para>

<para>
  One way to &#34;sweeten&#34; the act of selecting cards for battle
  is to add a simple visual effect. You can imagine, for instance,
  that in a fantasy battle, warriors chosen to go out onto the
  front line might glow with a magical aura. In video game design
  terms, that translates to a particle effect.
</para>

<para>
  Particle effects are relatively expensive, so you don't want to
  over-use them, especially on a relatively weak platform like the
  Pi. But as an indicator that something is &#34;hot&#34; and ready
  for battle, it&#39;s justified.
</para>

<para>
  To set up a particle effect, you must point LÖVE to a graphic that
  is to be used as the actual particles. This particle serves as the
  raw material for the effect, and there are a few important
  attributes to set in order to keep the effect from devouring your
  processor and speading particles all over the screen.
</para>

<para>
  Add this particle setup code to the top matter of your
  <literal>game.lua</literal> file. The first line is for context&#58;
</para>

<programlisting><![CDATA[
set = inifile.parse('deck.ini')

local mana = love.graphics.newImage('img' .. d .. 'part.png')
parti = love.graphics.newParticleSystem(mana, 12)
parti:setParticleLifetime(2,5) -- Particles live span min,max
parti:setEmissionRate(4)
parti:setSizeVariation(1)
parti:setLinearAcceleration(-12,-12,12,0) --xmin,ymin,xmax,ymax
parti:setColors(255,255,255,255,255,255,255,0) --Fade
]]></programlisting>

<para>
  To use the effect, add it to your <literal>draw</literal>
  function. Its placement is important, since you probably want it to
  be rendered <emphasis>under</emphasis> the player cards so that the
  particles appear to be rising up from within or behind the selected
  cards. 
</para>

<programlisting><![CDATA[
for i,obj in pairs(grab) do
   local count = 1
   while count < obj.wide/mana:getWidth() do
      love.graphics.draw(parti,obj.x+(mana:getWidth()*count+1),obj.y+(pad/3))
      count = count+1
   end
end

for i,obj in pairs(hand) do -- this line for context
]]></programlisting>

<para>
  Since the particle graphic itself is quite small, this code uses a
  <literal>while</literal> loop to place a particle seed along the top
  edge of any card in the <literal>grab</literal> table.
</para>

<para>
  Finally, use the LÖVE <literal>update</literal> function to detect
  and update changes in the particles. It only needs to take action if
  the <literal>grab</literal> table is not empty&#58;
</para>

<programlisting><![CDATA[
function love.update(dt)
   if #grab > 0 then
      parti:update(dt)
   end
end
]]></programlisting>

<para>
  Launch your game again and select some cards for battle to see the
  effect.
</para>

<mediaobject>
    <info>
      <othercredit>
	<orgname>Slackermedia</orgname>
      </othercredit>
    </info>
    <alt>Particle effects</alt>
    <imageobject>
      <imagedata align="right" width="6in" format="PNG"
		 fileref="../img/Ch08_skenlon/particle.png"/>
    </imageobject>
  </mediaobject>

<bridgehead>Resolving conflict</bridgehead>

<para>
  To settle the outcome of a card battle, you must compare the
  player&#39;s cards selected for battle against the AI card being
  targeted. This happens only if 1 or more cards is present in the
  <literal>grab</literal> table, and only when a card in the AI horde
  has been clicked.
</para>

<para>
  There&#39;s also one important exception to any attack&#58; if the
  card is a Joker, then <emphasis>all</emphasis> cards in the horde
  are wiped out.
</para>

<para>
  To obliterate an entire hand, you can use a new function. Call it
  <literal>game.blast()</literal> and make it clear out whatever table
  it is provided&#58;
</para>

<programlisting><![CDATA[
function game.blast(tgt)
   local count = #tgt
   for i=0, count do tgt[i]=nil end
end
]]></programlisting>   

<para>
  This function is useful not only for a Joker attack, but also as a
  way to make sure a player is starting with an empty hand, horde,
  grab, and other tables, at the start of a new game. In fact, why not
  add summary blasts to the <literal>game.new()</literal> function now&#58;
</para>

<programlisting><![CDATA[
function game.new()
   game.blast(deck)
   game.blast(ai)
   game.blast(hand)
   game.blast(horde)
   game.blast(back)
   game.blast(grab)
   winner   = nil

   scale = game.scaler(WIDE,790)

   -- start new game
   STATE = game
   math.randomseed(os.time())

   game.setup()
end
]]></programlisting>

<para>
  If you launch your game and draw a few cards, and then press
  <keycombo><keycap>Esc</keycap></keycombo> to bring up the menu, and
  then start a new game, you find that a new game is now, finally,
  truly a new game.
</para>

<para>
  Resolving battle, though, is still incomplete. Aside from the
  <literal>blast</literal> function, it mostly happens within the
  <literal>mousereleased</literal> function.
</para>

<para>
  Order is important, now. Currently, your
  <literal>mousereleased</literal> function checks whether the mouse
  button is button 1 and then takes action. But the button will always
  be button 1, so new qualifiers are required. For instance, if the
  mouse button is 1 and there are cards currently grabbed, then check
  to see if it was a card in the <literal>horde</literal> table that
  was clicked. If so, then it&#39;s time to battle. If not, then
  check that the click was button 1 and that a card in the
  <literal>back</literal> table was clicked, and draw a card.
</para>

<para>
  In addition to removing the attacked horde cards, though, the
  player&#39;s resources require adjustment. The cards used in the
  attack are also removed from the player hand. However, this must
  only happen if the attack is successful, since a player could
  attempt to attack without enough power to actually remove cards from
  the field. You must decide through play testing whether a successful
  attack must be greater than a black card, or if a card that is equal
  to or greater than a black card is victorious. The sample code here
  allows for cards both equal in value and greater in value to defeat
  the opponent. 
</para>

<para>
  Create a new function called <literal>game.postbattle()</literal>
  that will perform the menial task of removing cards from a table.
</para>

<programlisting><![CDATA[
function game.postbattle(src,tgt)
   for i,card in ipairs(src) do --remove grabbed cards
      k = game.isselected(card,src)
      src[k] = nil
      k = game.isselected(card,tgt)
      table.remove(tgt,k)
   end
end
]]></programlisting>

<para>
  And then perform the checks and balances of battle in the
  <literal>mousereleased</literal> function&#58;
</para>
  
<programlisting><![CDATA[
function game.mousereleased(x,y,btn)
   local attack = 0
   
   if btn == 1 and #grab > 0 then
      for i,obj in pairs(horde) do     --examine each card in horde
	 if game.clicker(x,y,obj) then --get horde card that got clicked

	    for i,card in pairs(grab) do --check value of grabbed cards
	       attack >= attack+tonumber(card.value) --add value to total attack

	       if card.face == "joker" then
		  game.blast(horde)
		  game.postbattle(grab,hand)
	       end --if
	    end --for
	    
	    if attack > tonumber(obj.value) then
	       -- remove from horde
	       k = game.isselected(obj,horde)
	       table.remove(horde,k)
	       game.postbattle(grab,hand)
	    end --if
	 end
      end
   elseif btn == 1 then
      --take a card
      for i,obj in pairs(back) do
	 if game.clicker(x,y,obj) and y > HIGH-slot-pad then
	    card = game.cardgen(deck)
	    card = game.cardgen(ai)
	 end --if
      end --for
   end --elseif
end
]]></programlisting>

<para>
  Launch your game and take out the opposition. There&#39;s no win or lose
  condition yet, but the basic mechanic and game play is
  complete. Your game is now firmly in alpha.
</para>


  <!--para>
If you decide your cards need drop shadows to separate them from the background&#58;
</para>

<programlisting><![CDATA[
convert 1-mystic.png -bordercolor None -border 10x10 \( +clone -background None -shadow 80x3+5+5 \)           -compose DstOver -composite -compose Over output.png
]]></programlisting-->



  </section>    

</chapter>
